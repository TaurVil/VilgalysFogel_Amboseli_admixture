#!/bin/env Rscript

# Script for calculating the number of ancestry informative markers in given genomic windows across the genome

# Load R libraries
library(dplyr)

# Load R data file containing positions data frame generated by 1prep_for_pedigree_inconsistencies.R script
load("local_ancestry_pedigree_trios_unmaskedWallref.Rd", verbose=T)

# We only need the positions data frame so remove other three data frames
rm(indiv_list, tracts2, trios)

# Load all ancestry calls in Amboseli individuals
calls <- read.table("/data/tunglab/asf40/wgs_data/MedGenome_ftp/local_ancestry_finalizedgenos/ancestry_usingWallref/amboseli_indiv/aims_CHROMOSOME_unmaskedWallref_n442.txt", header=F)

colnames(calls) <-  c("chrom", "AIM", "call", "indiv",  "n", "mode", "n_mode", "perc")
calls_unique <- distinct(calls, AIM)

# We'll do one chromosome per script
tmp <- positions[positions$chrom=="chrCHROMOSOME",]

# Print the total number of ancestry informative markers called across all individuals (not unique!)
print(nrow(tmp))

# Count the number of ancestry informative markers in genomic windows defined by the size variable surrounding each position

# Define window size
size=35000 # use 35 kb as our window size because this is the same window used for calling ancestry in LCLAE 

tmp$start_window <- tmp$pos-(size/2) # define starting position of the genomic window
tmp$end_window <- tmp$pos+(size/2) # define ending position of the genomic window
tmp$AIM_count <- NA # make column where the unique number of ancestry informative markers will be put
tmp$total_calls_population <- NA # make column where the total number of ancestry calls across the Amboseli population in the given genomic window will be put
tmp$mean_calls_per_AIM <- NA # make column where the mean number of ancestry calls per AIM (across the Amboseli population) will be put
tmp$sd_calls <- NA # make column where the mean number of ancestry calls per AIM (across the Amboseli population) will be put

# For each genomic window
for (i in 1:nrow(tmp)) {
   
   tmp2 <- tmp[i,]
   tmp3 <- subset(calls_unique, AIM>=tmp2$start_window & AIM<=tmp2$end_window)
   tmp$AIM_count[i] <- nrow(tmp3)

   tmp4 <- subset(calls, AIM>=tmp2$start_window & AIM<=tmp2$end_window)
   tmp$total_calls_population[i] <- nrow(tmp4)

   tmp5 <- tmp4 %>% group_by(AIM) %>% summarize(count=n())

if (nrow(tmp5)>0) {

   tmp$mean_calls_per_AIM[i] <- mean(tmp5$count)
   tmp$sd_calls[i] <- sd(tmp5$count)

}

   print(i)

}

# These are the column names for the output tmp but we will leave column names out for now because we'll need to concatenate all chromosome files into one file at the end 
#colnames(qual3) <- c("chrom", "pos", "start_window", "end_window", "AIM_count", "total_calls_population", "mean_calls_per_AIM", "sd_calls")
write.table(tmp,file="for_pedigree_trios_AIM_count_unmaskedWallref_pedigree_trios_chrCHROMOSOME.txt",quote=F,row.names=F, col.names=F)

print("done")
q(save="no")
